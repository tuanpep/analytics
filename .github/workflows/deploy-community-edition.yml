name: Deploy Plausible Community Edition

on:
  push:
    branches: [main, stable]
    paths:
      - 'compose.yml'
      - 'compose.override.yml'
      - '.env'
      - 'clickhouse/**'
      - '.github/workflows/deploy-community-edition.yml'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging
          - development

env:
  DOCKER_COMPOSE_VERSION: v2.20.0

jobs:
  validate:
    name: Validate Configuration
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Validate Docker Compose
        run: |
          docker compose config --quiet
          echo "✅ Docker Compose configuration is valid"

      - name: Check required files
        run: |
          if [ ! -f "compose.yml" ]; then
            echo "❌ compose.yml is missing"
            exit 1
          fi
          echo "✅ Required files present"

  deploy:
    name: Deploy Plausible Community Edition
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment || 'production' }}
    needs: validate
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Configure environment
        run: |
          echo "Deploying to environment: ${{ github.event.inputs.environment || 'production' }}"
          
          # Set environment-specific variables
          if [ "${{ github.event.inputs.environment || 'production' }}" = "production" ]; then
            echo "BASE_URL=${{ vars.PRODUCTION_BASE_URL }}" >> $GITHUB_ENV
            echo "HTTP_PORT=${{ vars.PRODUCTION_HTTP_PORT || '80' }}" >> $GITHUB_ENV
            echo "HTTPS_PORT=${{ vars.PRODUCTION_HTTPS_PORT || '443' }}" >> $GITHUB_ENV
          elif [ "${{ github.event.inputs.environment || 'production' }}" = "staging" ]; then
            echo "BASE_URL=${{ vars.STAGING_BASE_URL }}" >> $GITHUB_ENV
            echo "HTTP_PORT=${{ vars.STAGING_HTTP_PORT || '8000' }}" >> $GITHUB_ENV
          else
            echo "BASE_URL=${{ vars.DEV_BASE_URL || 'http://localhost:8000' }}" >> $GITHUB_ENV
            echo "HTTP_PORT=${{ vars.DEV_HTTP_PORT || '8000' }}" >> $GITHUB_ENV
          fi
          
          echo "SECRET_KEY_BASE=${{ secrets.SECRET_KEY_BASE }}" >> $GITHUB_ENV
          echo "TOTP_VAULT_KEY=${{ secrets.TOTP_VAULT_KEY }}" >> $GITHUB_ENV

      - name: Create .env file
        run: |
          cat > .env << EOF
          BASE_URL=${{ env.BASE_URL }}
          SECRET_KEY_BASE=${{ secrets.SECRET_KEY_BASE }}
          TOTP_VAULT_KEY=${{ secrets.TOTP_VAULT_KEY }}
          HTTP_PORT=${{ env.HTTP_PORT }}
          EOF
          
          if [ ! -z "${{ env.HTTPS_PORT }}" ]; then
            echo "HTTPS_PORT=${{ env.HTTPS_PORT }}" >> .env
          fi

      - name: Create compose.override.yml
        run: |
          cat > compose.override.yml << EOF
          services:
            plausible:
              ports:
                - "${{ env.HTTP_PORT }}:${{ env.HTTP_PORT }}"
          EOF
          
          if [ ! -z "${{ env.HTTPS_PORT }}" ]; then
            cat >> compose.override.yml << EOF
                - "${{ env.HTTPS_PORT }}:${{ env.HTTPS_PORT }}"
          EOF
          fi

      - name: Deploy with Docker Compose
        run: |
          # Pull latest images
          docker compose pull
          
          # Deploy services
          docker compose up -d
          
          # Wait for services to be healthy
          docker compose ps
          
          # Check service health with timeout
          timeout 300 bash -c 'until docker compose ps | grep -q "healthy"; do sleep 10; echo "Waiting for services to be healthy..."; done'

      - name: Verify deployment
        run: |
          # Wait for application to be ready
          sleep 30
          
          # Test HTTP response
          curl -f -I ${{ env.BASE_URL }} || exit 1
          
          echo "✅ Plausible Community Edition deployed successfully!"
          echo "🌐 Application is available at: ${{ env.BASE_URL }}"

      - name: Notify deployment status
        if: always()
        run: |
          if [ ${{ job.status }} == 'success' ]; then
            echo "🎉 Deployment successful!"
            echo "Plausible is available at: ${{ env.BASE_URL }}"
          else
            echo "❌ Deployment failed!"
            docker compose logs
          fi

  rollback:
    name: Rollback deployment
    runs-on: ubuntu-latest
    if: failure()
    needs: deploy
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Rollback to previous version
        run: |
          echo "🔄 Rolling back deployment..."
          docker compose down
          docker compose up -d
          echo "✅ Rollback completed"

  health-check:
    name: Health Check
    runs-on: ubuntu-latest
    needs: deploy
    if: success()
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Wait for services
        run: |
          sleep 60

      - name: Health check
        run: |
          # Check all services are running
          docker compose ps
          
          # Test database connections
          docker compose exec -T plausible_db pg_isready -U postgres
          
          # Test ClickHouse
          docker compose exec -T plausible_events_db wget --no-verbose --tries=1 -O - http://127.0.0.1:8123/ping
          
          # Test Plausible application
          curl -f ${{ env.BASE_URL }}/health || curl -f ${{ env.BASE_URL }}/
          
          echo "✅ All health checks passed!"

  cleanup:
    name: Cleanup
    runs-on: ubuntu-latest
    if: always()
    needs: [deploy, health-check]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Cleanup Docker resources
        if: failure()
        run: |
          echo "🧹 Cleaning up Docker resources..."
          docker system prune -f
          docker volume prune -f 